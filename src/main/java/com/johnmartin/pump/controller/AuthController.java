package com.johnmartin.pump.controller;

import java.util.Optional;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.johnmartin.pump.constants.ApiConstants;
import com.johnmartin.pump.constants.ApiErrorMessages;
import com.johnmartin.pump.dto.request.LoginRequest;
import com.johnmartin.pump.dto.request.RegisterRequest;
import com.johnmartin.pump.dto.response.ApiErrorResponse;
import com.johnmartin.pump.dto.response.AuthResponse;
import com.johnmartin.pump.dto.response.Result;
import com.johnmartin.pump.dto.response.UserResponse;
import com.johnmartin.pump.entities.UserEntity;
import com.johnmartin.pump.security.JwtUtil;
import com.johnmartin.pump.service.UserService;
import com.johnmartin.pump.utilities.LoggerUtility;
import com.johnmartin.pump.utils.ApiErrorUtils;

import io.micrometer.common.util.StringUtils;

@RestController
@RequestMapping(ApiConstants.Path.API_AUTH)
public class AuthController {
    private static final String DEBUG_TAG = AuthController.class.getSimpleName();

    @Autowired
    private UserService userService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtUtil jwtUtil;

    @PostMapping(ApiConstants.Path.REGISTER)
    public ResponseEntity<Result<AuthResponse>> register(@RequestBody RegisterRequest request) {
        ApiErrorResponse apiErrorResponse = new ApiErrorResponse();

        if (StringUtils.isBlank(request.getEmail()) || StringUtils.isBlank(request.getPassword())) {
            return ApiErrorUtils.createBadRequestErrorResponse(ApiErrorMessages.User.EMAIL_AND_PASSWORD_ARE_REQUIRED);
        }

        if (userService.findByEmail(request.getEmail()).isPresent()) {
            return ApiErrorUtils.createConflictErrorResponse(ApiErrorMessages.User.USER_WITH_THIS_EMAIL_ALREADY_EXISTS);
        }

        UserEntity userEntity = new UserEntity();
        userEntity.setId(UUID.randomUUID().toString());
        userEntity.setFirstName(request.getFirstName());
        userEntity.setLastName(request.getLastName());
        userEntity.setEmail(request.getEmail());
        userEntity.setPhone(request.getPhone());
        userEntity.setRole(request.getRole());
        userEntity.setProfileImageUrl(request.getProfileImageUrl());
        userEntity.setPassword(passwordEncoder.encode(request.getPassword()));

        UserEntity createdUser;
        try {
            // ID is generated by MongoDB
            createdUser = userService.createUser(userEntity);

            AuthResponse authResponse = new AuthResponse();
            authResponse.setUserResponse(new UserResponse(createdUser.getId(),
                                                          createdUser.getFirstName(),
                                                          createdUser.getLastName(),
                                                          createdUser.getEmail(),
                                                          createdUser.getPhone(),
                                                          createdUser.getRole(),
                                                          createdUser.getProfileImageUrl()));
            return ResponseEntity.ok(Result.success(authResponse));
        } catch (Exception e) {
            LoggerUtility.e(DEBUG_TAG, ApiErrorMessages.User.USER_REGISTRATION_FAILED + " e: " + e.getMessage(), e);
            return ApiErrorUtils.createInternalServerErrorResponse(ApiErrorMessages.User.USER_REGISTRATION_FAILED);
        }
    }

    @PostMapping(ApiConstants.Path.LOGIN)
    public ResponseEntity<Result<AuthResponse>> login(@RequestBody LoginRequest request) {
        Optional<UserEntity> userOpt = userService.findByEmail(request.getEmail());
        if (userOpt.isEmpty()) {
            return ApiErrorUtils.createNotFoundErrorResponse(String.format(ApiErrorMessages.User.USER_WITH_EMAIL_NOT_FOUND,
                                                                           request.getEmail()));
        }

        UserEntity dbUser = userOpt.get();

        try {
            if (!passwordEncoder.matches(request.getPassword(), dbUser.getPassword())) {
                return ApiErrorUtils.createUnauthorizedErrorResponse(ApiErrorMessages.User.INVALID_CREDENTIALS);
            }

            String token = jwtUtil.generateToken(dbUser.getEmail());

            UserResponse userResponse = new UserResponse(dbUser.getId(),
                                                         dbUser.getFirstName(),
                                                         dbUser.getLastName(),
                                                         dbUser.getEmail(),
                                                         dbUser.getPhone(),
                                                         dbUser.getRole(),
                                                         dbUser.getProfileImageUrl());

            AuthResponse authResponse = new AuthResponse();
            authResponse.setToken(token);
            authResponse.setUserResponse(userResponse);

            return ResponseEntity.ok(Result.success(authResponse));

        } catch (Exception e) {
            LoggerUtility.e(DEBUG_TAG, e.getMessage(), e);
            return ApiErrorUtils.createInternalServerErrorResponse(ApiErrorMessages.LOGIN_FAILED_PLEASE_TRY_AGAIN_LATER);
        }
    }

}
