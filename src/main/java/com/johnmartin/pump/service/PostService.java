package com.johnmartin.pump.service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import com.johnmartin.pump.constants.UIConstants;
import com.johnmartin.pump.constants.api.ApiErrorMessages;
import com.johnmartin.pump.dto.request.CreatePostRequest;
import com.johnmartin.pump.dto.request.UpdatePostRequest;
import com.johnmartin.pump.dto.response.PostResponse;
import com.johnmartin.pump.entities.PostEntity;
import com.johnmartin.pump.entities.UserEntity;
import com.johnmartin.pump.exception.BadRequestException;
import com.johnmartin.pump.exception.ResourceNotFoundException;
import com.johnmartin.pump.exception.UnauthorizedException;
import com.johnmartin.pump.mapper.PostMapper;
import com.johnmartin.pump.repository.PostRepository;
import com.johnmartin.pump.service.core.BaseService;
import com.johnmartin.pump.utilities.LoggerUtility;

import jakarta.transaction.Transactional;

@Service
public class PostService extends BaseService {

    private static final String DEBUG_TAG = PostService.class.getSimpleName();

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private CommentService commentService;

    /**
     * Get posts with 10 latest comments
     * 
     * @param page
     *            - page
     * @return List of PostResponse
     */
    public List<PostResponse> getPostsWithLatestComments(int page) {
        LoggerUtility.d(DEBUG_TAG, String.format("Execute method: [getPostsWithLatestComments], page: [%d]", page));

        PageRequest pageRequest = PageRequest.of(page, UIConstants.MINIMUM_POSTS);
        Page<PostEntity> postPage = postRepository.findAllByOrderByCreatedAtDesc(pageRequest);
        List<PostEntity> posts = postPage.getContent();

        if (posts.isEmpty()) {
            throw new ResourceNotFoundException(ApiErrorMessages.Post.THERE_ARE_NO_POST_AVAILABLE);
        }

        List<PostResponse> postResponses = posts.stream()
                                                .map(post -> PostMapper.toResponse(post,
                                                                                   commentService.getComments(post.getId(),
                                                                                                              0),
                                                                                   post.getUserId()))
                                                .toList();

        LoggerUtility.v(DEBUG_TAG, String.format("postResponseList size: [%d]", postResponses.size()));

        return postResponses;
    }

    /**
     * Create a post
     * 
     * @param request
     *            - CreatePostRequest
     * @return PostResponse
     */
    public PostResponse createPost(CreatePostRequest request) {
        LoggerUtility.d(DEBUG_TAG, String.format("Execute method: [createPost] request: [%s]", request));

        if (request == null) {
            throw new BadRequestException(ApiErrorMessages.INVALID_REQUEST);
        }

        if (StringUtils.isBlank(request.getDescription())) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_DESCRIPTION_IS_REQUIRED);
        }

        UserEntity user = getAuthenticatedUser();

        PostEntity createdPost = new PostEntity();
        createdPost.setTitle(request.getTitle());
        createdPost.setDescription(request.getDescription());
        createdPost.setUserId(user.getId());
        createdPost.setUserName(user.getFirstName() + " " + user.getLastName());
        createdPost.setUserProfileImageUrl(user.getProfileImageUrl());
        createdPost.setLikesCount(0);
        createdPost.setCommentsCount(0);
        createdPost.setSharesCount(0);

        LoggerUtility.v(DEBUG_TAG, String.format("createdPost: [%s]", createdPost));

        // ID and Dates are generated by MongoDB after insertion
        PostEntity postToBeReturned = postRepository.save(createdPost);
        LoggerUtility.v(DEBUG_TAG, String.format("postToBeReturned: [%s]", postToBeReturned));
        return PostMapper.toResponse(postToBeReturned, new ArrayList<>(), user.getId());
    }

    /**
     * Like a post
     * 
     * @param postId
     *            - Post ID
     * @return PostResponse
     */
    public PostResponse likePost(String postId) {
        LoggerUtility.d(DEBUG_TAG, String.format("Execute method: [likePost] postId: [%s]", postId));

        if (StringUtils.isBlank(postId)) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        PostEntity post = getPostById(postId);
        UserEntity user = getAuthenticatedUser();

        // If user already liked the post, unlike
        if (CollectionUtils.containsAny(post.getLikedUserIds(), user.getId())) {
            postRepository.unlikePost(user.getId(), postId);
        } else {
            postRepository.likePost(user.getId(), postId);
        }

        // Get updated post to get updated like state
        PostEntity updatedPost = getPostById(postId);
        LoggerUtility.v(DEBUG_TAG, String.format("updatedPost: [%s]", updatedPost));
        return PostMapper.toResponse(updatedPost, commentService.getComments(post.getId(), 0), user.getId());
    }

    /**
     * Get post info
     * 
     * @param postId
     *            - Post ID
     * @return PostResponse
     */
    public PostResponse getPostInfo(String postId) {
        LoggerUtility.d(DEBUG_TAG, String.format("Execute method: [getPostInfo] postId: [%s]", postId));

        if (StringUtils.isBlank(postId)) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        UserEntity user = getAuthenticatedUser();
        PostEntity postToBeReturned = getPostById(postId);
        LoggerUtility.d(DEBUG_TAG, String.format("postToBeReturned: [%s]", postToBeReturned));
        return PostMapper.toResponse(postToBeReturned, commentService.getComments(postId, 0), user.getId());
    }

    /**
     * Delete a post
     * 
     * @param postId
     *            - Post ID
     */
    @Transactional
    public void deletePost(String postId) {
        LoggerUtility.d(DEBUG_TAG, String.format("Execute method: [deletePost] postId: [%s]", postId));

        if (StringUtils.isBlank(postId)) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        UserEntity user = getAuthenticatedUser();
        PostEntity post = getPostById(postId);

        // Only post owner can delete
        if (!post.getUserId().equals(user.getId())) {
            throw new UnauthorizedException(ApiErrorMessages.User.YOU_ARE_NOT_AUTHORIZED_TO_PERFORM_THIS_ACTION);
        }

        // Delete all comments under the post
        commentService.deleteByPostId(postId);

        // Delete the post
        postRepository.deleteById(postId);
    }

    @Transactional
    public PostResponse updatePost(String postId, UpdatePostRequest request) {
        LoggerUtility.d(DEBUG_TAG,
                        String.format("Execute method: [updatePost] postId: [%s] request: [%s]", postId, request));

        if (StringUtils.isBlank(postId)) {
            throw new BadRequestException(ApiErrorMessages.Post.POST_ID_IS_REQUIRED);
        }

        if (request == null) {
            throw new BadRequestException(ApiErrorMessages.INVALID_REQUEST);
        }

        UserEntity user = getAuthenticatedUser();
        PostEntity post = getPostById(postId);

        // Only owner can edit
        if (!post.getUserId().equals(user.getId())) {
            throw new UnauthorizedException(ApiErrorMessages.User.YOU_ARE_NOT_AUTHORIZED_TO_PERFORM_THIS_ACTION);
        }

        // Update allowed fields only
        post.setTitle(request.getTitle());
        post.setDescription(request.getDescription());
        post.setUpdatedAt(Instant.now());

        PostEntity updatedPost = postRepository.save(post);
        LoggerUtility.v(DEBUG_TAG, String.format("updatedPost: [%s]", updatedPost));
        return PostMapper.toResponse(updatedPost, commentService.getComments(postId, 0), user.getId());
    }

    /**
     * Increment comments count
     * 
     * @param postId
     *            - Post ID
     */
    public void incrementCommentsCount(String postId) {
        postRepository.incrementCommentsCount(postId);
    }

    /**
     * Decrement comments count
     *
     * @param postId
     *            - Post ID
     */
    public void decrementCommentsCount(String postId) {
        postRepository.decrementCommentsCount(postId);
    }

    /**
     * Get post by post ID
     *
     * @param postId
     *            - Post ID
     * @return PostEntity or null
     */
    private PostEntity getPostById(String postId) {
        return postRepository.findById(postId)
                             .orElseThrow(() -> new ResourceNotFoundException(ApiErrorMessages.Post.POST_NOT_FOUND));
    }
}
